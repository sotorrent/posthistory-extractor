Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
64356018;23459881;769275;2;3246c9bd-190f-4ee0-b4f5-4931696e3cde;2014-05-04 18:20:00.0;"I'm trying to unit test some persistence code and I run into the problem that the database hangs on to the rows creating in previous tests. I am also using Hibernate Search although this is not reflected in the code I'm sharing here.&#xD;&#xA;&#xD;&#xA;I'm using Spring 3.1.x, Hibernate 4.x and HSQLDB 2.3.2&#xD;&#xA;&#xD;&#xA;Log&#xD;&#xA;&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: insert into UserRole (userRoleId, label) values (default, ?)&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[EntityKey[nl.project.model.user.UserRole#1]],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: insert into UserRole (userRoleId, label) values (default, ?)&#xD;&#xA;&#xD;&#xA;		***First test****&#xD;&#xA;&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.processRollback(843) | Initiating transaction rollback&#xD;&#xA;		DEBUG - HibernateTransactionManager.doRollback(496) | Rolling back Hibernate transaction on Session [SessionImpl(PersistenceContext[entityKeys=[EntityKey[nl.project.model.user.User#1],EntityKey[nl.project.model.user.UserRole#1],EntityKey[nl.project.model.user.UserRole#2], EntityKey[nl.project.model.user.UserRole#3]],collectionKeys=[CollectionKey[nl.project.model.user.User.roles#1]]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])]&#xD;&#xA;		DEBUG - HibernateTransactionManager.doBegin(342) | Opened new Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - HibernateTransactionManager.doBegin(352) | Preparing JDBC Connection of Hibernate Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])]&#xD;&#xA;		DEBUG - HibernateTransactionManager.doBegin(413) | Exposing Hibernate transaction as JDBC transaction [com.jolbox.bonecp.ConnectionHandle@73d17d67]&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: select this_.userRoleId as userRole1_92_0_, this_.label as label2_92_0_ from UserRole this_&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[EntityKey[nl.project.model.user.UserRole#3], EntityKey[nl.project.model.user.UserRole#2], EntityKey[nl.project.model.user.UserRole#1]],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: insert into UserRole (userRoleId, label) values (default, ?)&#xD;&#xA;		WARN - SqlExceptionHelper.logExceptions(144) | SQL Error: -104, SQLState: 23505&#xD;&#xA;		ERROR - SqlExceptionHelper.logExceptions(146) | integrity constraint violation: unique constraint or index violation; UK_O0VIK8LBO8UYMR8WUDN5T21QX table: USERROLE&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Code&#xD;&#xA;&#xD;&#xA;		public class CoreTest extends TestCase {&#xD;&#xA;	&#xD;&#xA;			@Inject&#xD;&#xA;			protected SimpleManager<Long> simpleMgr; &#xD;&#xA;	&#xD;&#xA;			public void baseSetup(){&#xD;&#xA;		&#xD;&#xA;				simpleMgr.flush();&#xD;&#xA;                                simpleMgr.clear();&#xD;&#xA;&#xD;&#xA;		                //after 1st test this contains all created UserRoles&#xD;&#xA;				List roles = simpleMgr.getAll(UserRole.class);&#xD;&#xA;		                &#xD;&#xA;				UserRole role = new UserRole(UserRole.ROLE_ANONYMOUS);&#xD;&#xA;				simpleMgr.save(role);&#xD;&#xA;		&#xD;&#xA;				role = new UserRole(UserRole.ROLE_USER);&#xD;&#xA;				simpleMgr.save(role);&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		@RunWith(SpringJUnit4ClassRunner.class)&#xD;&#xA;		@ContextConfiguration(locations = {&#xD;&#xA;				""classpath:/spring/applicationContext.xml""&#xD;&#xA;				""classpath:/spring/applicationContext-transaction.xml""})&#xD;&#xA;		public class MyManagerTest extends CoreTest{&#xD;&#xA;&#xD;&#xA;			@Before&#xD;&#xA;			public void methodSetup(){&#xD;&#xA;		&#xD;&#xA;				super.baseSetup();&#xD;&#xA;		&#xD;&#xA;				role = new UserRole(UserRole.ROLE_PROUSER);&#xD;&#xA;				simpleMgr.save(role);&#xD;&#xA;		&#xD;&#xA;				simpleMgr.save(userMgr.createUser(""marc"", ""marc@gmail.com""));&#xD;&#xA;		&#xD;&#xA;				simpleMgr.flush();&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			@Test&#xD;&#xA;			@Transactional&#xD;&#xA;			public void test1(){&#xD;&#xA;				...&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			@Test&#xD;&#xA;			@Transactional&#xD;&#xA;			public void test2(){&#xD;&#xA;				....&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;Transaction management&#xD;&#xA;&#xD;&#xA;		<bean id=""dataSource"" class=""org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"">&#xD;&#xA;			<property name=""targetDataSource"" ref=""mainDataSource""/>&#xD;&#xA;		</bean>&#xD;&#xA;	&#xD;&#xA;		<bean id=""mainDataSource"" class=""com.jolbox.bonecp.BoneCPDataSource"" destroy-method=""close"">&#xD;&#xA;			<property name=""driverClass"" value=""${jdbc.driverClassName}""/>&#xD;&#xA;			[...]&#xD;&#xA;		</bean>&#xD;&#xA;		<bean id=""sessionFactory"" class=""org.springframework.orm.hibernate4.LocalSessionFactoryBean"">&#xD;&#xA;			<property name=""dataSource"" ref=""dataSource""/>&#xD;&#xA;			<property name=""configLocation"" value=""classpath:hibernate.cfg.xml""/>&#xD;&#xA;			<property name=""hibernateProperties"">&#xD;&#xA;				<value>&#xD;&#xA;					hibernate.connection.driver_class=${jdbc.driverClassName}&#xD;&#xA;					hibernate.jdbc.batch_size=30&#xD;&#xA;					hibernate.dialect=${hibernate.dialect}&#xD;&#xA;					hibernate.connection.autoReconnect=true&#xD;&#xA;					hibernate.connection.autoReconnectForPools=true&#xD;&#xA;					hibernate.connection.autocommit=false&#xD;&#xA;				</value>&#xD;&#xA;			</property>&#xD;&#xA;		</bean>&#xD;&#xA;		<bean id=""transactionManager"" class=""org.springframework.orm.hibernate4.HibernateTransactionManager"">&#xD;&#xA;			<property name=""sessionFactory"" ref=""sessionFactory""/>&#xD;&#xA;		</bean>";;
64356224;23459881;769275;5;65b485b0-c045-4e2b-b457-bbe9266beb37;2014-05-04 18:25:27.0;"I'm trying to unit test some persistence code and I run into the problem that the database hangs on to the rows creating in previous tests. I am also using Hibernate Search although this is not reflected in the code I'm sharing here.&#xD;&#xA;&#xD;&#xA;I'm using Spring 3.1.x, Hibernate 4.x and HSQLDB 2.3.2&#xD;&#xA;&#xD;&#xA;Log&#xD;&#xA;&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: insert into UserRole (userRoleId, label) values (default, ?)&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[EntityKey[nl.project.model.user.UserRole#1]],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: insert into UserRole (userRoleId, label) values (default, ?)&#xD;&#xA;&#xD;&#xA;		***First test****&#xD;&#xA;&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.processRollback(843) | Initiating transaction rollback&#xD;&#xA;		DEBUG - HibernateTransactionManager.doRollback(496) | Rolling back Hibernate transaction on Session [SessionImpl(PersistenceContext[entityKeys=[EntityKey[nl.project.model.user.User#1],EntityKey[nl.project.model.user.UserRole#1],EntityKey[nl.project.model.user.UserRole#2], EntityKey[nl.project.model.user.UserRole#3]],collectionKeys=[CollectionKey[nl.project.model.user.User.roles#1]]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])]&#xD;&#xA;		DEBUG - HibernateTransactionManager.doBegin(342) | Opened new Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - HibernateTransactionManager.doBegin(352) | Preparing JDBC Connection of Hibernate Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])]&#xD;&#xA;		DEBUG - HibernateTransactionManager.doBegin(413) | Exposing Hibernate transaction as JDBC transaction [com.jolbox.bonecp.ConnectionHandle@73d17d67]&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: select this_.userRoleId as userRole1_92_0_, this_.label as label2_92_0_ from UserRole this_&#xD;&#xA;		DEBUG - HibernateTransactionManager.doGetTransaction(290) | Found thread-bound Session [SessionImpl(PersistenceContext[entityKeys=[EntityKey[nl.project.model.user.UserRole#3], EntityKey[nl.project.model.user.UserRole#2], EntityKey[nl.project.model.user.UserRole#1]],collectionKeys=[]];ActionQueue[insertions=[] updates=[] deletions=[] orphanRemovals=[] collectionCreations=[] collectionRemovals=[] collectionUpdates=[] collectionQueuedOps=[] unresolvedInsertDependencies=UnresolvedEntityInsertActions[]])] for Hibernate transaction&#xD;&#xA;		DEBUG - AbstractPlatformTransactionManager.handleExistingTransaction(470) | Participating in existing transaction&#xD;&#xA;		Hibernate: insert into UserRole (userRoleId, label) values (default, ?)&#xD;&#xA;		WARN - SqlExceptionHelper.logExceptions(144) | SQL Error: -104, SQLState: 23505&#xD;&#xA;		ERROR - SqlExceptionHelper.logExceptions(146) | integrity constraint violation: unique constraint or index violation; UK_O0VIK8LBO8UYMR8WUDN5T21QX table: USERROLE&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Code&#xD;&#xA;&#xD;&#xA;	@Entity&#xD;&#xA;	@Immutable&#xD;&#xA;	@Table&#xD;&#xA;	@NaturalIdCache(region=CacheRegion.NATURAL)&#xD;&#xA;	@Cache(usage=CacheConcurrencyStrategy.NONSTRICT_READ_WRITE,region=CacheRegion.USER)&#xD;&#xA;	public class UserRole implements Serializable{&#xD;&#xA;&#xD;&#xA;		public static final String ROLE_ANONYMOUS=""ROLE_ANONYMOUS"";&#xD;&#xA;		public static final String ROLE_USER=""ROLE_USER"";&#xD;&#xA;		public static final String ROLE_PROVENDOR=""ROLE_PROVENDOR"";&#xD;&#xA;	&#xD;&#xA;		@Id&#xD;&#xA;		@GeneratedValue(strategy = GenerationType.AUTO)&#xD;&#xA;		@Column(nullable=false, updatable=false)&#xD;&#xA;		private Long id;&#xD;&#xA;	&#xD;&#xA;		@Column(nullable=false,unique=true,updatable=false)&#xD;&#xA;		@NaturalId&#xD;&#xA;		private String label;&#xD;&#xA;&#xD;&#xA;		...&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;Code&#xD;&#xA;&#xD;&#xA;		public class CoreTest extends TestCase {&#xD;&#xA;	&#xD;&#xA;			@Inject&#xD;&#xA;			protected SimpleManager<Long> simpleMgr; &#xD;&#xA;	&#xD;&#xA;			public void baseSetup(){&#xD;&#xA;		&#xD;&#xA;				simpleMgr.flush();&#xD;&#xA;                                simpleMgr.clear();&#xD;&#xA;&#xD;&#xA;		                //after 1st test this contains all created UserRoles&#xD;&#xA;				List roles = simpleMgr.getAll(UserRole.class);&#xD;&#xA;		                &#xD;&#xA;				UserRole role = new UserRole(UserRole.ROLE_ANONYMOUS);&#xD;&#xA;				simpleMgr.save(role);&#xD;&#xA;		&#xD;&#xA;				role = new UserRole(UserRole.ROLE_USER);&#xD;&#xA;				simpleMgr.save(role);&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		@RunWith(SpringJUnit4ClassRunner.class)&#xD;&#xA;		@ContextConfiguration(locations = {&#xD;&#xA;				""classpath:/spring/applicationContext.xml""&#xD;&#xA;				""classpath:/spring/applicationContext-transaction.xml""})&#xD;&#xA;		public class MyManagerTest extends CoreTest{&#xD;&#xA;&#xD;&#xA;			@Before&#xD;&#xA;			public void methodSetup(){&#xD;&#xA;		&#xD;&#xA;				super.baseSetup();&#xD;&#xA;		&#xD;&#xA;				role = new UserRole(UserRole.ROLE_PROUSER);&#xD;&#xA;				simpleMgr.save(role);&#xD;&#xA;		&#xD;&#xA;				simpleMgr.save(userMgr.createUser(""marc"", ""marc@gmail.com""));&#xD;&#xA;		&#xD;&#xA;				simpleMgr.flush();&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			@Test&#xD;&#xA;			@Transactional&#xD;&#xA;			public void test1(){&#xD;&#xA;				...&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			@Test&#xD;&#xA;			@Transactional&#xD;&#xA;			public void test2(){&#xD;&#xA;				....&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;Transaction management&#xD;&#xA;&#xD;&#xA;		<bean id=""dataSource"" class=""org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"">&#xD;&#xA;			<property name=""targetDataSource"" ref=""mainDataSource""/>&#xD;&#xA;		</bean>&#xD;&#xA;	&#xD;&#xA;		<bean id=""mainDataSource"" class=""com.jolbox.bonecp.BoneCPDataSource"" destroy-method=""close"">&#xD;&#xA;			<property name=""driverClass"" value=""${jdbc.driverClassName}""/>&#xD;&#xA;			[...]&#xD;&#xA;		</bean>&#xD;&#xA;		<bean id=""sessionFactory"" class=""org.springframework.orm.hibernate4.LocalSessionFactoryBean"">&#xD;&#xA;			<property name=""dataSource"" ref=""dataSource""/>&#xD;&#xA;			<property name=""configLocation"" value=""classpath:hibernate.cfg.xml""/>&#xD;&#xA;			<property name=""hibernateProperties"">&#xD;&#xA;				<value>&#xD;&#xA;					hibernate.connection.driver_class=${jdbc.driverClassName}&#xD;&#xA;					hibernate.jdbc.batch_size=30&#xD;&#xA;					hibernate.dialect=${hibernate.dialect}&#xD;&#xA;					hibernate.connection.autoReconnect=true&#xD;&#xA;					hibernate.connection.autoReconnectForPools=true&#xD;&#xA;					hibernate.connection.autocommit=false&#xD;&#xA;				</value>&#xD;&#xA;			</property>&#xD;&#xA;		</bean>&#xD;&#xA;		<bean id=""transactionManager"" class=""org.springframework.orm.hibernate4.HibernateTransactionManager"">&#xD;&#xA;			<property name=""sessionFactory"" ref=""sessionFactory""/>&#xD;&#xA;		</bean>";;added 663 characters in body
