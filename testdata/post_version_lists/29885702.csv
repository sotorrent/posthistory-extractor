Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
89087426;29885702;49251;2;e6c9a734-4033-4506-8428-dd272c3aa5c9;2015-04-27 01:22:15.0;"    var resultArray = cost.Where(item => item <= 29).ToArray();";;
89087627;29885702;49251;5;0b6f2113-a926-44cf-a22f-bad2e8dcf1a3;2015-04-27 01:31:18.0;"    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 420 characters in body
89087804;29885702;49251;5;daca4778-c3a4-4242-b742-88cb3ed94504;2015-04-27 01:37:38.0;"Here's one of the simplest things you can do for this:&#xD;&#xA;&#xD;&#xA;    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;Here's another:&#xD;&#xA;&#xD;&#xA;    var resultArray = Array.FindAll(cost, item => item <= 29);&#xD;&#xA;&#xD;&#xA;The first option uses extension methods that operate on `IEnumerable`, which arrays implement.&#xD;&#xA;&#xD;&#xA;The second option uses FindAll, which is actually built in to the `Array` class.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;Looks like you removed reference to finding indexes, so the below is no longer relevant, but it shows how to find both values and indexes of the array elements that satisfy the condition:&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 205 characters in body
89088340;29885702;49251;5;e97270e8-69a7-4695-a550-85b3f1aea2d9;2015-04-27 01:54:24.0;"Here's one of the simplest things you can do for this:&#xD;&#xA;&#xD;&#xA;    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;Here's another:&#xD;&#xA;&#xD;&#xA;    var resultArray = Array.FindAll(cost, item => item <= 29);&#xD;&#xA;&#xD;&#xA;1. The first option uses extension methods that operate on `IEnumerable`, which arrays implement.&#xD;&#xA;&#xD;&#xA;2. The second option uses FindAll, which is actually built in to the `Array` class.&#xD;&#xA;&#xD;&#xA;The `item => item <= 29` stuff is `lambda notation`.  It's a highly concise way of defining a function on the spot. &#xD;&#xA;&#xD;&#xA;This way of writing an anonymous function on the spot is saying&#xD;&#xA;&#xD;&#xA; - `Where` or `FindAll` each receive an argument that is a function.&#xD;&#xA; - The function receives as its one argument an element, which we'll call `item` (the name could be anything, it could also be `x`), which is an individual element of the Array (or IEnumerable)--elements being `int`s in this case--which the compiler infers. The name of the function argument is left of the `=>`&#xD;&#xA; - the function body is right of the `=>`.  (Read `=>` as ""this is a function where the argument `item` goes to the body"") The body is an expression that evaulates to a `Boolean` `true` or a `false`, so the return value of the function is a `Boolean`.&#xD;&#xA;&#xD;&#xA; So, essentially `item => item <= 29` is the same as declaring a function like the below, but it's much more concise and can be easily used as an argument to another function. Here's the long way of declaring such a function, so you can see that the lambda way of writing it is much more concise:&#xD;&#xA;&#xD;&#xA;    bool int func(int x)&#xD;&#xA;    {&#xD;&#xA;        if (x<=29) {&#xD;&#xA;            return true;&#xD;&#xA;        } else {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;Looks like you removed reference to finding indexes, so the below is no longer relevant, but it shows how to find both values and indexes of the array elements that satisfy the condition:&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 205 characters in body
89088386;29885702;49251;5;d9d32c11-045f-4d45-89f4-eb1f5f195f4e;2015-04-27 01:56:04.0;"Here's one of the simplest things you can do for this:&#xD;&#xA;&#xD;&#xA;    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;Here's another:&#xD;&#xA;&#xD;&#xA;    var resultArray = Array.FindAll(cost, item => item <= 29);&#xD;&#xA;&#xD;&#xA;1. The first option uses extension methods that operate on `IEnumerable`, which arrays implement.&#xD;&#xA;&#xD;&#xA;2. The second option uses FindAll, which is actually built in to the `Array` class.&#xD;&#xA;&#xD;&#xA;The `item => item <= 29` stuff is `lambda notation`.  It's a highly concise way of defining a function on the spot. &#xD;&#xA;&#xD;&#xA;This way of writing an anonymous function on the spot is saying&#xD;&#xA;&#xD;&#xA; - `Where` or `FindAll` each receive an argument that is a function, and we will define that argument right here in the actual call to `Where` or `FindAll`.&#xD;&#xA; - The function receives as its one argument an element, which we'll call `item` (the name could be anything, it could also be `x`), which is an individual element of the Array (or IEnumerable)--elements being `int`s in this case--which the compiler infers. The name of the function argument is left of the `=>`&#xD;&#xA; - the function body is right of the `=>`.  (Read `=>` as ""this is a function where the argument `item` goes to the body"") The body is an expression that evaulates to a `Boolean` `true` or a `false`, so the return value of the function is a `Boolean`.&#xD;&#xA;&#xD;&#xA; So, essentially `item => item <= 29` is the same as declaring a function like the below, but it's much more concise and can be easily used as an argument to another function. Here's the long way of declaring such a function, so you can see that the lambda way of writing it is much more concise:&#xD;&#xA;&#xD;&#xA;    bool int func(int x)&#xD;&#xA;    {&#xD;&#xA;        if (x<=29) {&#xD;&#xA;            return true;&#xD;&#xA;        } else {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;Looks like you removed reference to finding indexes, so the below is no longer relevant, but it shows how to find both values and indexes of the array elements that satisfy the condition:&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 205 characters in body
89088602;29885702;49251;5;a8dd06cd-c7b4-4811-bbbd-af156ce7db6f;2015-04-27 02:02:38.0;"Here's one of the simplest things you can do for this:&#xD;&#xA;&#xD;&#xA;    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;Here's another:&#xD;&#xA;&#xD;&#xA;    var resultArray = Array.FindAll(cost, item => item <= 29);&#xD;&#xA;&#xD;&#xA;1. The first option uses extension methods that operate on `IEnumerable`, which arrays implement.&#xD;&#xA;&#xD;&#xA;2. The second option uses FindAll, which is actually built in to the `Array` class.&#xD;&#xA;&#xD;&#xA;The `item => item <= 29` stuff is `lambda notation`.  It's a highly concise way of defining a function on the spot. &#xD;&#xA;&#xD;&#xA;This way of writing an anonymous function on the spot is saying&#xD;&#xA;&#xD;&#xA; - `Where` or `FindAll` each receive an argument that is an anonymous function, and we will define that argument that is an anonymous function right here in the actual call to `Where()` or `FindAll()`.&#xD;&#xA; - The anonymous function itself receives as its own one argument an element, which we'll call `item` (the name could be anything, it could also be `x`). This item is an individual element of the `Array` (or `IEnumerable`)--elements being `int`s in this case--which the compiler infers. The name of the function argument is left of the `=>`&#xD;&#xA; - the function body is right of the `=>`.  (Read `=>` as ""this is a function where the argument `item` goes to the body"") The body is an expression that evaulates to a `Boolean` `true` or a `false`, so the return value of the function is a `Boolean`.&#xD;&#xA;&#xD;&#xA;So, essentially `item => item <= 29` is the same as declaring a function like the below, but it's much more concise and can be easily used as an argument to another function. Here's the long way of declaring such a function, so you can see that the lambda way of writing it is much more concise:&#xD;&#xA;&#xD;&#xA;    bool int func(int x)&#xD;&#xA;    {&#xD;&#xA;        if (x<=29) {&#xD;&#xA;            return true;&#xD;&#xA;        } else {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; - the `Where` or `Array.FindAll` functions call the lambda function on each element in the `Array` or `IEnumerable` and return (yield) back only those items where the lambda function returns true.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;Looks like you removed reference to finding indexes, so the below is no longer relevant, but it shows how to find both values and indexes of the array elements that satisfy the condition:&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 205 characters in body
89088756;29885702;49251;5;e68e71ce-b5a5-4d3a-b3af-db45550be757;2015-04-27 02:07:40.0;"Here's one of the simplest things you can do for this:&#xD;&#xA;&#xD;&#xA;    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;Here's another:&#xD;&#xA;&#xD;&#xA;    var resultArray = Array.FindAll(cost, item => item <= 29);&#xD;&#xA;&#xD;&#xA;1. The first option uses an extension methods named `Where` that operates on `IEnumerable`, which arrays implement.  `IEnumerable` is an interface for a sequence of elements that can be stepped through one after the other.&#xD;&#xA;&#xD;&#xA;2. The second option uses `FindAll`, which is actually built in to the `Array` class.&#xD;&#xA;&#xD;&#xA;The `item => item <= 29` stuff is `lambda notation`.  It's a highly concise way of defining a function on the spot. &#xD;&#xA;&#xD;&#xA;This way of writing an anonymous function on the spot is saying&#xD;&#xA;&#xD;&#xA; - `Where` or `FindAll` each receive an argument that is an anonymous function, and we will define that argument that is an anonymous function right here in the actual call to `Where()` or `FindAll()`.&#xD;&#xA; - The anonymous function itself receives as its own one argument an element, which we'll call `item` (the name could be anything, it could also be `x`). This item is an individual element of the `Array` (or `IEnumerable`)--elements being `int`s in this case--which the compiler infers. The name of the function argument is left of the `=>`&#xD;&#xA; - the function body is right of the `=>`.  (Read `=>` as ""this is a function where the argument `item` goes to the body right of the `=>` "") The body is an expression that evaulates to a `Boolean` `true` or a `false`, so the return value of the function is a `Boolean`.&#xD;&#xA;&#xD;&#xA;So, essentially `item => item <= 29` is the same as declaring a function like the below, but it's much more concise and can be easily used as an argument to another function. Here's the long way of declaring such a function, so you can see that the lambda way of writing it is much more concise:&#xD;&#xA;&#xD;&#xA;    Boolean int func(int x)&#xD;&#xA;    {&#xD;&#xA;        if (x<=29) {&#xD;&#xA;            return true;&#xD;&#xA;        } else {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; - the `Where` or `Array.FindAll` functions call the lambda function on each element in the `Array` or `IEnumerable` and return (yield) back only those items where the lambda function returns true.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;Looks like you removed reference to finding indexes, so the below is no longer relevant, but it shows how to find both values and indexes of the array elements that satisfy the condition:&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 205 characters in body
89093797;29885702;49251;5;92497ff5-fd9a-40bd-808b-6c5648613f26;2015-04-27 04:27:16.0;"Here's one of the simplest things you can do for this:&#xD;&#xA;&#xD;&#xA;    var resultArray = cost.Where(item => item <= 29).ToArray();&#xD;&#xA;&#xD;&#xA;Here's another:&#xD;&#xA;&#xD;&#xA;    var resultArray = Array.FindAll(cost, item => item <= 29);&#xD;&#xA;&#xD;&#xA;1. The first option uses an extension methods named `Where` that operates on `IEnumerable`, which arrays implement.  `IEnumerable` is an interface for a sequence of elements that can be stepped through one after the other.&#xD;&#xA;&#xD;&#xA;2. The second option uses `FindAll`, which is actually built in to the `Array` class.&#xD;&#xA;&#xD;&#xA;The `item => item <= 29` stuff is `lambda notation`.  It's a highly concise way of defining a function on the spot. &#xD;&#xA;&#xD;&#xA;This way of writing an anonymous function on the spot is saying&#xD;&#xA;&#xD;&#xA; - `Where` or `FindAll` each receive an argument that is an anonymous function, and we will define that argument that is an anonymous function right here in the actual call to `Where()` or `FindAll()`.&#xD;&#xA; - The anonymous function itself receives as its own one argument an element, which we'll call `item` (the name could be anything, it could also be `x`). This item is an individual element of the `Array` (or `IEnumerable`)--elements being `int`s in this case--which the compiler infers. The name of the function argument is left of the `=>`&#xD;&#xA; - the function body is right of the `=>`.  (Read `=>` as ""this is a function where the argument `item` goes to the body right of the `=>` "") The body is an expression that evaulates to a `Boolean` `true` or a `false`, so the return value of the function is a `Boolean`.&#xD;&#xA;&#xD;&#xA;So, essentially `item => item <= 29` is the same as declaring a function like the below, but it's much more concise and can be easily used as an argument to another function. Here's the long way of declaring such a function, so you can see that the lambda way of writing it is much more concise:&#xD;&#xA;&#xD;&#xA;    Boolean int func(int x)&#xD;&#xA;    {&#xD;&#xA;        if (x<=29) {&#xD;&#xA;            return true;&#xD;&#xA;        } else {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; - the `Where` or `Array.FindAll` functions call the lambda function on each element in the `Array` or `IEnumerable` and return (yield) back only those items where the lambda function returns true.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;Looks like you edited the original question to remove a reference to finding indexes, so the below is no longer relevant (the above stuff finds values of elements, not indexes of elements).  But the below shows how to find both values and indexes of the array elements that satisfy the condition:&#xD;&#xA;&#xD;&#xA;You mentioned indexes.  This version also finds the indexes of the original array (not just the elements) that satisfy the criterion:&#xD;&#xA;&#xD;&#xA;    List<int> indexesInvolved = new List<int>();&#xD;&#xA;    var resultArray = cost.Where((item, index) =>&#xD;&#xA;        { &#xD;&#xA;            if (item <= 29) {&#xD;&#xA;                indexesInvolved.Add(index);&#xD;&#xA;                return true;&#xD;&#xA;            } &#xD;&#xA;            else {&#xD;&#xA;                return false;&#xD;&#xA;            } &#xD;&#xA;        }&#xD;&#xA;     ).ToArray();&#xD;&#xA;    var foundIndexArray = indexesInvolved.ToArray();";;added 109 characters in body
