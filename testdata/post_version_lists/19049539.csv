Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
48155213;19049539;1281750;2;6d5d8088-53da-4487-8dad-67a737fa9a69;2013-09-27 11:25:06.0;"Hold a reference of Activity in your fragment to handle that nullpointerexception. &#xD;&#xA;&#xD;&#xA;Here is an example of a fragment. &#xD;&#xA;&#xD;&#xA;    public class YourFragment extends Fragment {&#xD;&#xA;    &#xD;&#xA;    	private Activity mActivity;&#xD;&#xA;    &#xD;&#xA;    	@Override&#xD;&#xA;    	public void onAttach(Activity activity) {&#xD;&#xA;    		super.onAttach(activity);&#xD;&#xA;    		mActivity = activity;&#xD;&#xA;    	}&#xD;&#xA;    	&#xD;&#xA;    	@Override&#xD;&#xA;    	public void onResume() {&#xD;&#xA;    		super.onResume();&#xD;&#xA;    		// BIND sensor here with mActivity, &#xD;&#xA;            // could also be done in other fragment lifecycle events, &#xD;&#xA;            // depends on how you handle configChanges&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    	&#xD;&#xA;    	@Override&#xD;&#xA;    	public void onPause() {&#xD;&#xA;    		super.onPause();&#xD;&#xA;    		// UNBIND sensor here from mActivity, &#xD;&#xA;            // could also be done in other fragment lifecycle events, &#xD;&#xA;            // depends on how you handle configChanges&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;        &#xD;&#xA;&#xD;&#xA;Debug that code do determine if you should handle the binding there or in another method e.g. onCreate of a fragment. I have not tested this code for your purpose. ";;
48175567;19049539;1281750;5;e29daee7-8df4-46a0-856c-196f6a135f59;2013-09-27 16:13:15.0;"Hold a reference of Activity in your fragment to handle that nullpointerexception. &#xD;&#xA;&#xD;&#xA;Here is an example of a fragment. &#xD;&#xA;&#xD;&#xA;    public class YourFragment extends Fragment {&#xD;&#xA;    &#xD;&#xA;    	private Activity mActivity;&#xD;&#xA;    &#xD;&#xA;    	@Override&#xD;&#xA;    	public void onAttach(Activity activity) {&#xD;&#xA;    		super.onAttach(activity);&#xD;&#xA;    		mActivity = activity;&#xD;&#xA;    	}&#xD;&#xA;    	&#xD;&#xA;    	@Override&#xD;&#xA;    	public void onResume() {&#xD;&#xA;    		super.onResume();&#xD;&#xA;    		// BIND sensor here with mActivity, &#xD;&#xA;            // could also be done in other fragment lifecycle events, &#xD;&#xA;            // depends on how you handle configChanges&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    	&#xD;&#xA;    	@Override&#xD;&#xA;    	public void onPause() {&#xD;&#xA;    		super.onPause();&#xD;&#xA;    		// UNBIND sensor here from mActivity, &#xD;&#xA;            // could also be done in other fragment lifecycle events, &#xD;&#xA;            // depends on how you handle configChanges&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;        &#xD;&#xA;&#xD;&#xA;Debug that code do determine if you should handle the binding there or in another method e.g. onCreate of a fragment. I have not tested this code for your purpose. &#xD;&#xA;&#xD;&#xA;Edit: &#xD;&#xA;This is indeed as commented below a dirty fix and could easily resolve into exceptions in some cases. I just wanted to show how you can use fragment lifecycle methods to bind and unbind sensors with a reference to activity. I'm currently learning fragments for quite some time but still don't understand them thoroughly. I advice you to take a look at the source of [Fragment][1] and other components involved. This is the only place were fragments are documented thoroughly hence the documentation on reference in my opinion isn't that explanatory.  &#xD;&#xA;&#xD;&#xA;Some of the options regarding null value Activity:&#xD;&#xA;&#xD;&#xA; - If you want to be completely sure that getActivity doesn't return null you should wait for [onActivityCreated][2] to be called.  This method tells the fragment that its activity has&#xD;&#xA; completed its own Activity.onCreate(). After this getActivity() will not return null until initState() gets called by the FragmentManager.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;         // Called by the fragment manager once this fragment has been removed,&#xD;&#xA;         // so that we don't have any left-over state if the application decides&#xD;&#xA;         // to re-use the instance.  This only clears state that the framework&#xD;&#xA;         // internally manages, not things the application sets.&#xD;&#xA;         &#xD;&#xA;        void initState() {&#xD;&#xA;            mIndex = -1;&#xD;&#xA;            mWho = null;&#xD;&#xA;            mAdded = false;&#xD;&#xA;            mRemoving = false;&#xD;&#xA;            mResumed = false;&#xD;&#xA;            mFromLayout = false;&#xD;&#xA;            mInLayout = false;&#xD;&#xA;            mRestored = false;&#xD;&#xA;            mBackStackNesting = 0;&#xD;&#xA;            mFragmentManager = null;&#xD;&#xA;            mActivity = null;&#xD;&#xA;            mFragmentId = 0;&#xD;&#xA;            mContainerId = 0;&#xD;&#xA;            mTag = null;&#xD;&#xA;            mHidden = false;&#xD;&#xA;            mDetached = false;&#xD;&#xA;            mRetaining = false;&#xD;&#xA;            mLoaderManager = null;&#xD;&#xA;            mLoadersStarted = false;&#xD;&#xA;            mCheckedForLoaderManager = false;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA; &#xD;&#xA; - Before you call getActivity you can always check if activity isn't null by calling isAdded() method. As you can see below this method checks if mActivity isn't null. Optionally you can create a recursive function with Handler.postDelayed that tries to return an non null Activity in intervalls (you should add a max try counter). But this is also a dirty trick.   &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;       &#xD;&#xA;        //Return true if the fragment is currently added to its activity.&#xD;&#xA;        &#xD;&#xA;        final public boolean isAdded() {&#xD;&#xA;            return mActivity != null && mAdded;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.0.1_r1/android/app/Fragment.java/?v=source&#xD;&#xA;  [2]: http://developer.android.com/images/fragment_lifecycle.png&#xD;&#xA;";;added 2770 characters in body
