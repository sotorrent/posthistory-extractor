Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
117952386;37196630;2204410;2;e92ed645-1f3d-48e9-8b5f-efa51b663ea9;2016-05-12 20:16:25.0;"Using the `data.table` package and assuming your `Start` and `End` columns are in date-format:&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(count = 1 + (max(Start,End) - min(Start,End))), by = Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group   count&#xD;&#xA;    1:     A  3 days&#xD;&#xA;    2:     B  3 days&#xD;&#xA;    3:     H 16 days";;
117952950;37196630;2204410;5;0ccb949d-a698-47b8-8e0a-69a9a24f4141;2016-05-12 20:24:22.0;"Using the `data.table` package and assuming your `Start` and `End` columns are in date-format:&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(count = 1 + (max(Start,End) - min(Start,End))), by = Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group   count&#xD;&#xA;    1:     A  3 days&#xD;&#xA;    2:     B  3 days&#xD;&#xA;    3:     H 16 days&#xD;&#xA;&#xD;&#xA;The same operation with `dplyr`:&#xD;&#xA;&#xD;&#xA;    mydf %>%&#xD;&#xA;      group_by(Group) %>%&#xD;&#xA;      summarise(count = 1 + (max(Start,End) - min(Start,End)))&#xD;&#xA;&#xD;&#xA;which will give you the same result.&#xD;&#xA;";;added 185 characters in body
117953545;37196630;2204410;5;190cf545-9ffe-4542-85ef-cdf5b0cb5dd5;2016-05-12 20:33:27.0;"If you want to count the unique days by group, I would do (assuming your `Start` and `End` columns are in date-format):&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(intervals = seq.Date(Start,End,'day')) , .(Group,1:nrow(mydf))&#xD;&#xA;                ][, .(count = uniqueN(intervals)), Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group count&#xD;&#xA;    1:     A     3&#xD;&#xA;    2:     B     3&#xD;&#xA;    3:     H    16&#xD;&#xA;&#xD;&#xA;*Explanation*: For each row you create date sequences with the `Start` and `End` dates. After that you count the unique days with the `uniqueN` function. This is better than my old answer ( see below) because when there are days somewhere between `max(Start,End)` and `min(Start,End)` which are not present in the intervals, the old answer will count to many days.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;**Old answer:** Using the `data.table` package and assuming your `Start` and `End` columns are in date-format:&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(count = 1 + (max(Start,End) - min(Start,End))), by = Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group   count&#xD;&#xA;    1:     A  3 days&#xD;&#xA;    2:     B  3 days&#xD;&#xA;    3:     H 16 days&#xD;&#xA;&#xD;&#xA;The same operation with `dplyr`:&#xD;&#xA;&#xD;&#xA;    mydf %>%&#xD;&#xA;      group_by(Group) %>%&#xD;&#xA;      summarise(count = 1 + (max(Start,End) - min(Start,End)))&#xD;&#xA;&#xD;&#xA;which will give you the same result.&#xD;&#xA;&#xD;&#xA;";;added 519 characters in body
117954015;37196630;2204410;5;a80466e0-361b-4cde-b283-994e74e2721a;2016-05-12 20:40:53.0;"If you want to count the unique days by group, I would do (assuming your `Start` and `End` columns are in date-format):&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(intervals = seq.Date(Start,End,'day')) , .(Group,1:nrow(mydf))&#xD;&#xA;                ][, .(count = uniqueN(intervals)), Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group count&#xD;&#xA;    1:     A     3&#xD;&#xA;    2:     B     3&#xD;&#xA;    3:     H    16&#xD;&#xA;&#xD;&#xA;*Explanation*: For each row you create date sequences with the `Start` and `End` dates. After that you count the unique days with the `uniqueN` function. This is better than my old answer ( see below) because when there are days somewhere between `max(Start,End)` and `min(Start,End)` which are not present in the intervals, the old answer will count to many days.&#xD;&#xA;&#xD;&#xA;This gives a higher number for the `H` group compared to your described desired output. However, if you look closely to your data, you will see that the correct number is `16`.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;**Old answer:** Using the `data.table` package and assuming your `Start` and `End` columns are in date-format:&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(count = 1 + (max(Start,End) - min(Start,End))), by = Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group   count&#xD;&#xA;    1:     A  3 days&#xD;&#xA;    2:     B  3 days&#xD;&#xA;    3:     H 16 days&#xD;&#xA;&#xD;&#xA;The same operation with `dplyr`:&#xD;&#xA;&#xD;&#xA;    mydf %>%&#xD;&#xA;      group_by(Group) %>%&#xD;&#xA;      summarise(count = 1 + (max(Start,End) - min(Start,End)))&#xD;&#xA;&#xD;&#xA;which will give you the same result.&#xD;&#xA;&#xD;&#xA;";;added 180 characters in body
117954365;37196630;2204410;5;7309e6e8-65c4-49fa-96c3-fe43d621aac6;2016-05-12 20:47:20.0;"If you want to count the unique days by group, I would do (assuming your `Start` and `End` columns are in date-format):&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(dates = seq.Date(Start,End,'day')) , .(Group,1:nrow(mydf))&#xD;&#xA;                ][, .(count = uniqueN(dates)), Group][]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group count&#xD;&#xA;    1:     A     3&#xD;&#xA;    2:     B     3&#xD;&#xA;    3:     H    16&#xD;&#xA;&#xD;&#xA;*Explanation*: For each row you create date sequences with the `Start` and `End` dates. After that you count the unique days with the `uniqueN` function. This is better than my old answer (see below) because this takes gaps into account.&#xD;&#xA;&#xD;&#xA;This gives a higher number for the `H` group compared to your described desired output. However, if you look closely to your data, you will see that the correct number is `16`.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;**Old answer:** Using the `data.table` package and assuming your `Start` and `End` columns are in date-format:&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(count = 1 + (max(Start,End) - min(Start,End))), by = Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group   count&#xD;&#xA;    1:     A  3 days&#xD;&#xA;    2:     B  3 days&#xD;&#xA;    3:     H 16 days&#xD;&#xA;&#xD;&#xA;The same operation with `dplyr`:&#xD;&#xA;&#xD;&#xA;    mydf %>%&#xD;&#xA;      group_by(Group) %>%&#xD;&#xA;      summarise(count = 1 + (max(Start,End) - min(Start,End)))&#xD;&#xA;&#xD;&#xA;which will give you the same result.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 4 characters in body
117956069;37196630;2204410;5;42112996-c6d0-4b29-8208-3d130462d5a3;2016-05-12 21:17:35.0;"If you want to count the unique days by group, I would do (assuming your `Start` and `End` columns are in date-format):&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(dates = seq.Date(Start,End,'day')) , by = .(Group,1:nrow(mydf))&#xD;&#xA;                ][, .(count = uniqueN(dates)), by = Group][]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group count&#xD;&#xA;    1:     A     3&#xD;&#xA;    2:     B     3&#xD;&#xA;    3:     H    16&#xD;&#xA;&#xD;&#xA;*Explanation*: For each row you create date sequences with the `Start` and `End` dates. After that you count the unique days with the `uniqueN` function. This is better than my old answer (see below) because this takes gaps into account.&#xD;&#xA;&#xD;&#xA;This gives a higher number for the `H` group compared to your described desired output. However, if you look closely to your data, you will see that the correct number is `16`.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;**Old answer:** Using the `data.table` package and assuming your `Start` and `End` columns are in date-format:&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(count = 1 + (max(Start,End) - min(Start,End))), by = Group]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group   count&#xD;&#xA;    1:     A  3 days&#xD;&#xA;    2:     B  3 days&#xD;&#xA;    3:     H 16 days&#xD;&#xA;&#xD;&#xA;The same operation with `dplyr`:&#xD;&#xA;&#xD;&#xA;    mydf %>%&#xD;&#xA;      group_by(Group) %>%&#xD;&#xA;      summarise(count = 1 + (max(Start,End) - min(Start,End)))&#xD;&#xA;&#xD;&#xA;which will give you the same result.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 10 characters in body
117990037;37196630;2204410;5;e90d8bda-20dc-47a7-bf51-b3909c2aabe4;2016-05-13 09:28:10.0;"If you want to count the unique days by group, I would do (assuming your `Start` and `End` columns are in date-format):&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(dates = seq.Date(Start,End,'day')) , by = .(Group,1:nrow(mydf))&#xD;&#xA;                ][, .(count = uniqueN(dates)), by = Group][]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group count&#xD;&#xA;    1:     A     3&#xD;&#xA;    2:     B     3&#xD;&#xA;    3:     H    16&#xD;&#xA;&#xD;&#xA;*Explanation*: For each row you create date sequences with the `Start` and `End` dates. After that you count the unique days with the `uniqueN` function. This is better than my old answer (see below) because this takes gaps into account.&#xD;&#xA;&#xD;&#xA;This gives a higher number for the `H` group compared to your described desired output. However, if you look closely to your data, you will see that the correct number is `16`.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;A similar solution with base R:&#xD;&#xA;&#xD;&#xA;    l <- mapply(seq.Date, mydf$Start, mydf$End, 1)&#xD;&#xA;    df2 <- data.frame(grp = rep(mydf$Group, sapply(l,length)),&#xD;&#xA;                      dates = as.Date(unlist(l), origin = '1970-01-01'))&#xD;&#xA;    aggregate(dates ~ grp, df2, function(x) length(unique(x)))&#xD;&#xA;&#xD;&#xA;which also gives:&#xD;&#xA;&#xD;&#xA;      grp dates&#xD;&#xA;    1   A     3&#xD;&#xA;    2   B     3&#xD;&#xA;    3   H    16&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;Used data:&#xD;&#xA;&#xD;&#xA;    mydf <- structure(list(Group = c(""A"", ""A"", ""B"", ""B"", ""H"", ""H"", ""H"", ""H"", ""H""), &#xD;&#xA;                           Start = structure(c(16567, 16567, 16436, 16436, 16443, 16443, 16448, 16442, 16447), class = ""Date""), &#xD;&#xA;                           End = structure(c(16569, 16569, 16438, 16438, 16444, 16444, 16450, 16452, 16457), class = ""Date""), &#xD;&#xA;                           Days = c(3L, 3L, 3L, 3L, 2L, 2L, 3L, 3L, 7L)), &#xD;&#xA;                      .Names = c(""Group"", ""Start"", ""End"", ""Days""), row.names = c(NA, -9L), class = ""data.frame"")&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 432 characters in body
118001757;37196630;2204410;5;4391cf07-6345-4ac2-a2ab-7ae81a99175b;2016-05-13 11:51:50.0;"If you want to count the unique days by group, I would do (assuming your `Start` and `End` columns are in date-format):&#xD;&#xA;&#xD;&#xA;    library(data.table)&#xD;&#xA;    setDT(mydf)[, .(dates = seq.Date(Start,End,'day')) , by = .(Group,1:nrow(mydf))&#xD;&#xA;                ][, .(count = uniqueN(dates)), by = Group][]&#xD;&#xA;&#xD;&#xA;which gives:&#xD;&#xA;&#xD;&#xA;       Group count&#xD;&#xA;    1:     A     3&#xD;&#xA;    2:     B     3&#xD;&#xA;    3:     H    16&#xD;&#xA;&#xD;&#xA;*Explanation*: For each row you create date sequences with the `Start` and `End` dates. After that you count the unique days with the `uniqueN` function. This is better than my old answer (see below) because this takes gaps into account.&#xD;&#xA;&#xD;&#xA;This gives a higher number for the `H` group compared to your described desired output. However, if you look closely to your data, you will see that the correct number is `16`.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;A similar solution with base R:&#xD;&#xA;&#xD;&#xA;    l <- mapply(seq.Date, mydf$Start, mydf$End, 1)&#xD;&#xA;    df2 <- data.frame(group = rep(mydf$Group,sapply(l,length)),&#xD;&#xA;                      dates = unlist(l))&#xD;&#xA;    aggregate(dates ~ group, df2, function(x) length(unique(x)))&#xD;&#xA;&#xD;&#xA;which gives a similar result:&#xD;&#xA;&#xD;&#xA;      group dates&#xD;&#xA;    1     A     3&#xD;&#xA;    2     B     3&#xD;&#xA;    3     H    16&#xD;&#xA;&#xD;&#xA;If you want the `dates` column in `df2` in date-format, use `as.Date(unlist(l), origin = '1970-01-01')` instead of `unlist(l)`.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;Used data:&#xD;&#xA;&#xD;&#xA;    mydf <- structure(list(Group = c(""A"", ""A"", ""B"", ""B"", ""H"", ""H"", ""H"", ""H"", ""H""), &#xD;&#xA;                           Start = structure(c(16567, 16567, 16436, 16436, 16443, 16443, 16448, 16442, 16447), class = ""Date""), &#xD;&#xA;                           End = structure(c(16569, 16569, 16438, 16438, 16444, 16444, 16450, 16452, 16457), class = ""Date""), &#xD;&#xA;                           Days = c(3L, 3L, 3L, 3L, 2L, 2L, 3L, 3L, 7L)), &#xD;&#xA;                      .Names = c(""Group"", ""Start"", ""End"", ""Days""), row.names = c(NA, -9L), class = ""data.frame"")&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 126 characters in body
