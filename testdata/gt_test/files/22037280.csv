Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
58996741;22037280;1501794;2;d5b2c473-1214-4ed2-ac86-8f73510482c2;2014-02-26 09:38:07.0;"You may try to change your program like this:&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;[Ideone][1]&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with BigDecimal.valueOf and not with new BigDecimal** is BigDecimal.valueOf(double) will use the canonical String representation of the double value passed in to instantiate the BigDecimal object. In other words: The value of the BigDecimal object will be what you see when you do System.out.println(d).&#xD;&#xA;&#xD;&#xA;If you use new BigDecimal(d) however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want. &#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;";;
58997388;22037280;1501794;5;a62339c3-9cab-4097-ab5f-155189438334;2014-02-26 09:44:41.0;"You may try to change your program like this:&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;[Ideone][1]&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with `BigDecimal.valueOf` and not with `new BigDecimal`** is `BigDecimal.valueOf(double)` will use the [canonical String representation][2] of the double value passed in to instantiate the BigDecimal object. In other words: The value of the BigDecimal object will be what you see when you do System.out.println(d).&#xD;&#xA;&#xD;&#xA;If you use `new BigDecimal(d)` however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want. Hence resulting in some **confusion** which you are watching in your program.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#toString%28double%29";;added 97 characters in body
59004094;22037280;1501794;5;ecedbb0b-735e-4a34-b010-902d9f7495ff;2014-02-26 10:59:04.0;"You may try to change your program like this:&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;[Ideone][1]&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with `BigDecimal.valueOf` and not with `new BigDecimal`** is `BigDecimal.valueOf(double)` will use the [canonical String representation][2] of the double value passed in to instantiate the BigDecimal object. In other words: The value of the BigDecimal object will be what you see when you do System.out.println(d).&#xD;&#xA;&#xD;&#xA;If you use `new BigDecimal(d)` however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want. Hence resulting in some **confusion** which you are watching in your program.&#xD;&#xA;&#xD;&#xA;From the Java Doc:&#xD;&#xA;&#xD;&#xA;> **[BigDecimal.valueOf(double val)][3]** - Translates a double into a BigDecimal, using the double's canonical string representation&#xD;&#xA;> provided by the Double.toString(double) method.&#xD;&#xA;> &#xD;&#xA;> **[new BigDecimal(double val)][4]** - &#xD;&#xA;> &#xD;&#xA;> Translates a double into a BigDecimal which is the exact decimal&#xD;&#xA;> representation of the double's binary floating-point value. The scale&#xD;&#xA;> of the returned BigDecimal is the smallest value such that (10scale ×&#xD;&#xA;> val) is an integer. Notes:&#xD;&#xA;> &#xD;&#xA;>  - The results of this constructor can be somewhat unpredictable. One    might assume that writing new BigDecimal(0.1) in Java creates a   &#xD;&#xA;> BigDecimal which is exactly equal to 0.1 (an unscaled value of 1,   &#xD;&#xA;> with a scale of 1), but it is actually equal to&#xD;&#xA;>    0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that   &#xD;&#xA;> matter, as a binary fraction of any finite length). Thus, the value   &#xD;&#xA;> that is being passed in to the constructor is not exactly equal to&#xD;&#xA;>    0.1, appearances notwithstanding.&#xD;&#xA;>  - The String constructor, on the other hand, is perfectly predictable:    writing new BigDecimal(""0.1"") creates a BigDecimal&#xD;&#xA;> which is exactly    equal to 0.1, as one would expect. Therefore, it&#xD;&#xA;> is generally    recommended that the String constructor be used in&#xD;&#xA;> preference to this    one.&#xD;&#xA;>  - When a double must be used as a source for a BigDecimal, note that    this constructor provides an exact conversion; it does not give the   &#xD;&#xA;> same result as converting the double to a String using the   &#xD;&#xA;> Double.toString(double) method and then using the BigDecimal(String)  &#xD;&#xA;> constructor. To get that result, use the static valueOf(double)   &#xD;&#xA;> method.&#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#toString%28double%29&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29";;added 1958 characters in body
59078493;22037280;1501794;5;d3ebcdf8-5872-40b2-8d10-7fb806f2f3ed;2014-02-27 05:25:31.0;"You may try to change your program like this:&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**[Sample Ideone][1]**&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with `BigDecimal.valueOf` and not with `new BigDecimal`** is `BigDecimal.valueOf(double)` will use the [canonical String representation][2] of the double value passed in to instantiate the BigDecimal object. In other words: The value of the BigDecimal object will be what you see when you do System.out.println(d).&#xD;&#xA;&#xD;&#xA;If you use `new BigDecimal(d)` however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want. Hence resulting in some **confusion** which you are watching in your program.&#xD;&#xA;&#xD;&#xA;From the Java Doc:&#xD;&#xA;&#xD;&#xA;> **[BigDecimal.valueOf(double val)][3]** - Translates a double into a BigDecimal, using the double's canonical string representation&#xD;&#xA;> provided by the Double.toString(double) method.&#xD;&#xA;> &#xD;&#xA;> **[new BigDecimal(double val)][4]** - &#xD;&#xA;> &#xD;&#xA;> Translates a double into a BigDecimal which is the exact decimal&#xD;&#xA;> representation of the double's binary floating-point value. The scale&#xD;&#xA;> of the returned BigDecimal is the smallest value such that (10scale ×&#xD;&#xA;> val) is an integer. Notes:&#xD;&#xA;> &#xD;&#xA;>  - The results of this constructor can be somewhat unpredictable. One    might assume that writing new BigDecimal(0.1) in Java creates a   &#xD;&#xA;> BigDecimal which is exactly equal to 0.1 (an unscaled value of 1,   &#xD;&#xA;> with a scale of 1), but it is actually equal to&#xD;&#xA;>    0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that   &#xD;&#xA;> matter, as a binary fraction of any finite length). Thus, the value   &#xD;&#xA;> that is being passed in to the constructor is not exactly equal to&#xD;&#xA;>    0.1, appearances notwithstanding.&#xD;&#xA;>  - The String constructor, on the other hand, is perfectly predictable:    writing new BigDecimal(""0.1"") creates a BigDecimal&#xD;&#xA;> which is exactly    equal to 0.1, as one would expect. Therefore, it&#xD;&#xA;> is generally    recommended that the String constructor be used in&#xD;&#xA;> preference to this    one.&#xD;&#xA;>  - When a double must be used as a source for a BigDecimal, note that    this constructor provides an exact conversion; it does not give the   &#xD;&#xA;> same result as converting the double to a String using the   &#xD;&#xA;> Double.toString(double) method and then using the BigDecimal(String)  &#xD;&#xA;> constructor. To get that result, use the static valueOf(double)   &#xD;&#xA;> method.&#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#toString%28double%29&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29";;added 11 characters in body
60329723;22037280;387076;5;ad86a374-16da-4483-940e-3b59903e9036;2014-03-13 21:04:54.0;"You may try to change your program like this:&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**[Sample Ideone][1]**&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with `BigDecimal.valueOf` and not with `new BigDecimal`**, in the words of [Joachim Sauer](http://stackoverflow.com/questions/7186204/bigdecimal-to-use-new-or-valueof/7186298#7186298):&#xD;&#xA;&#xD;&#xA;> `BigDecimal.valueOf(double)` will use the [canonical String representation][2] of the double value passed in to instantiate the BigDecimal object. In other words: The value of the `BigDecimal` object will be what you see when you do `System.out.println(d)`.&#xD;&#xA;&#xD;&#xA;> If you use `new BigDecimal(d)` however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want.&#xD;&#xA;&#xD;&#xA;Hence resulting in some **confusion** which you are watching in your program.&#xD;&#xA;&#xD;&#xA;From the Java Doc:&#xD;&#xA;&#xD;&#xA;> **[BigDecimal.valueOf(double val)][3]** - Translates a double into a BigDecimal, using the double's canonical string representation&#xD;&#xA;> provided by the Double.toString(double) method.&#xD;&#xA;> &#xD;&#xA;> **[new BigDecimal(double val)][4]** - &#xD;&#xA;> &#xD;&#xA;> Translates a double into a BigDecimal which is the exact decimal&#xD;&#xA;> representation of the double's binary floating-point value. The scale&#xD;&#xA;> of the returned BigDecimal is the smallest value such that (10scale ×&#xD;&#xA;> val) is an integer. Notes:&#xD;&#xA;> &#xD;&#xA;>  - The results of this constructor can be somewhat unpredictable. One    might assume that writing new BigDecimal(0.1) in Java creates a   &#xD;&#xA;> BigDecimal which is exactly equal to 0.1 (an unscaled value of 1,   &#xD;&#xA;> with a scale of 1), but it is actually equal to&#xD;&#xA;>    0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that   &#xD;&#xA;> matter, as a binary fraction of any finite length). Thus, the value   &#xD;&#xA;> that is being passed in to the constructor is not exactly equal to&#xD;&#xA;>    0.1, appearances notwithstanding.&#xD;&#xA;>  - The String constructor, on the other hand, is perfectly predictable:    writing new BigDecimal(""0.1"") creates a BigDecimal&#xD;&#xA;> which is exactly    equal to 0.1, as one would expect. Therefore, it&#xD;&#xA;> is generally    recommended that the String constructor be used in&#xD;&#xA;> preference to this    one.&#xD;&#xA;>  - When a double must be used as a source for a BigDecimal, note that    this constructor provides an exact conversion; it does not give the   &#xD;&#xA;> same result as converting the double to a String using the   &#xD;&#xA;> Double.toString(double) method and then using the BigDecimal(String)  &#xD;&#xA;> constructor. To get that result, use the static valueOf(double)   &#xD;&#xA;> method.&#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#toString%28double%29&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29";;added missing attribution for copied content
69262919;22037280;;5;63af6071-ddb5-4fa6-b6e0-2ff64c35f445;2014-07-14 04:55:27.0;"You may try to change your program like this:-&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**[Sample Ideone][1]**&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with `BigDecimal.valueOf` and not with `new BigDecimal`**, in the words of [Joachim Sauer](http://stackoverflow.com/questions/7186204/bigdecimal-to-use-new-or-valueof/7186298#7186298):&#xD;&#xA;&#xD;&#xA;> `BigDecimal.valueOf(double)` will use the [canonical String representation][2] of the double value passed in to instantiate the BigDecimal object. In other words: The value of the `BigDecimal` object will be what you see when you do `System.out.println(d)`.&#xD;&#xA;&#xD;&#xA;> If you use `new BigDecimal(d)` however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want.&#xD;&#xA;&#xD;&#xA;Hence resulting in some **confusion** which you are watching in your program.&#xD;&#xA;&#xD;&#xA;From the Java Doc:&#xD;&#xA;&#xD;&#xA;> **[BigDecimal.valueOf(double val)][3]** - Translates a double into a BigDecimal, using the double's canonical string representation&#xD;&#xA;> provided by the Double.toString(double) method.&#xD;&#xA;> &#xD;&#xA;> **[new BigDecimal(double val)][4]** - &#xD;&#xA;> &#xD;&#xA;> Translates a double into a BigDecimal which is the exact decimal&#xD;&#xA;> representation of the double's binary floating-point value. The scale&#xD;&#xA;> of the returned BigDecimal is the smallest value such that (10scale ×&#xD;&#xA;> val) is an integer. Notes:&#xD;&#xA;> &#xD;&#xA;>  - The results of this constructor can be somewhat unpredictable. One    might assume that writing new BigDecimal(0.1) in Java creates a   &#xD;&#xA;> BigDecimal which is exactly equal to 0.1 (an unscaled value of 1,   &#xD;&#xA;> with a scale of 1), but it is actually equal to&#xD;&#xA;>    0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that   &#xD;&#xA;> matter, as a binary fraction of any finite length). Thus, the value   &#xD;&#xA;> that is being passed in to the constructor is not exactly equal to&#xD;&#xA;>    0.1, appearances notwithstanding.&#xD;&#xA;>  - The String constructor, on the other hand, is perfectly predictable:    writing new BigDecimal(""0.1"") creates a BigDecimal&#xD;&#xA;> which is exactly    equal to 0.1, as one would expect. Therefore, it&#xD;&#xA;> is generally    recommended that the String constructor be used in&#xD;&#xA;> preference to this    one.&#xD;&#xA;>  - When a double must be used as a source for a BigDecimal, note that    this constructor provides an exact conversion; it does not give the   &#xD;&#xA;> same result as converting the double to a String using the   &#xD;&#xA;> Double.toString(double) method and then using the BigDecimal(String)  &#xD;&#xA;> constructor. To get that result, use the static valueOf(double)   &#xD;&#xA;> method.&#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#toString%28double%29&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29";user3414693;added 1 character in body
147248795;22037280;-1;5;5adcf652-2c93-429e-8643-f01ca232b6b0;2017-05-23 12:16:59.0;"You may try to change your program like this:-&#xD;&#xA;&#xD;&#xA;    static Double round(Double d, int precise) &#xD;&#xA;    {&#xD;&#xA;    BigDecimal bigDecimal = BigDecimal.valueOf(d);&#xD;&#xA;    bigDecimal = bigDecimal.setScale(precise, RoundingMode.HALF_UP);&#xD;&#xA;    return bigDecimal.doubleValue();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**[Sample Ideone][1]**&#xD;&#xA;&#xD;&#xA;    Success	 time: 0.07 memory: 381184 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;    &#xD;&#xA;    Success	 time: 0.07 memory: 381248 signal:0&#xD;&#xA;    Rounded: 2.66&#xD;&#xA;    Rounded: 1.66&#xD;&#xA;&#xD;&#xA;**Reason why you are getting the expected result with `BigDecimal.valueOf` and not with `new BigDecimal`**, in the words of [Joachim Sauer](https://stackoverflow.com/questions/7186204/bigdecimal-to-use-new-or-valueof/7186298#7186298):&#xD;&#xA;&#xD;&#xA;> `BigDecimal.valueOf(double)` will use the [canonical String representation][2] of the double value passed in to instantiate the BigDecimal object. In other words: The value of the `BigDecimal` object will be what you see when you do `System.out.println(d)`.&#xD;&#xA;&#xD;&#xA;> If you use `new BigDecimal(d)` however, then the BigDecimal will try to represent the double value as accurately as possible. This will usually result in a lot more digits being stored than you want.&#xD;&#xA;&#xD;&#xA;Hence resulting in some **confusion** which you are watching in your program.&#xD;&#xA;&#xD;&#xA;From the Java Doc:&#xD;&#xA;&#xD;&#xA;> **[BigDecimal.valueOf(double val)][3]** - Translates a double into a BigDecimal, using the double's canonical string representation&#xD;&#xA;> provided by the Double.toString(double) method.&#xD;&#xA;> &#xD;&#xA;> **[new BigDecimal(double val)][4]** - &#xD;&#xA;> &#xD;&#xA;> Translates a double into a BigDecimal which is the exact decimal&#xD;&#xA;> representation of the double's binary floating-point value. The scale&#xD;&#xA;> of the returned BigDecimal is the smallest value such that (10scale ×&#xD;&#xA;> val) is an integer. Notes:&#xD;&#xA;> &#xD;&#xA;>  - The results of this constructor can be somewhat unpredictable. One    might assume that writing new BigDecimal(0.1) in Java creates a   &#xD;&#xA;> BigDecimal which is exactly equal to 0.1 (an unscaled value of 1,   &#xD;&#xA;> with a scale of 1), but it is actually equal to&#xD;&#xA;>    0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that   &#xD;&#xA;> matter, as a binary fraction of any finite length). Thus, the value   &#xD;&#xA;> that is being passed in to the constructor is not exactly equal to&#xD;&#xA;>    0.1, appearances notwithstanding.&#xD;&#xA;>  - The String constructor, on the other hand, is perfectly predictable:    writing new BigDecimal(""0.1"") creates a BigDecimal&#xD;&#xA;> which is exactly    equal to 0.1, as one would expect. Therefore, it&#xD;&#xA;> is generally    recommended that the String constructor be used in&#xD;&#xA;> preference to this    one.&#xD;&#xA;>  - When a double must be used as a source for a BigDecimal, note that    this constructor provides an exact conversion; it does not give the   &#xD;&#xA;> same result as converting the double to a String using the   &#xD;&#xA;> Double.toString(double) method and then using the BigDecimal(String)  &#xD;&#xA;> constructor. To get that result, use the static valueOf(double)   &#xD;&#xA;> method.&#xD;&#xA;&#xD;&#xA;  [1]: http://ideone.com/sVHWjL&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#toString%28double%29&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#valueOf%28double%29";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
